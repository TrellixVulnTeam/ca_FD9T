import { Injectable, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { Location } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
export class AbstractNavigator {
    constructor(location, injector) {
        this.location = location;
        try {
            this.router = injector.get(Router);
        }
        catch (_a) { }
    }
    /**
     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back
     * to `window.history.replaceState`.
     * @param url The url to navigate to
     */
    navigateByUrl(url) {
        if (this.router) {
            this.router.navigateByUrl(url);
            return;
        }
        this.location.replaceState(url);
    }
}
AbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) { return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
AbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbstractNavigator_Factory() { return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR)); }, token: AbstractNavigator, providedIn: "root" });
AbstractNavigator.ctorParameters = () => [
    { type: Location },
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Location }, { type: ɵngcc0.Injector }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtbmF2aWdhdG9yLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9wcm9qZWN0cy9hdXRoMC1hbmd1bGFyL3NyYy9saWIvYWJzdHJhY3QtbmF2aWdhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0M7QUFHQTs7O0FBQ0EsTUFBTSxPQUFPLGlCQUFpQjtBQUM5QixJQUVFLFlBQW9CLFFBQWtCLEVBQUUsUUFBa0I7QUFDNUQsUUFEc0IsYUFBUSxHQUFSLFFBQVEsQ0FBVTtBQUFDLFFBQ3JDLElBQUk7QUFDUixZQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN6QyxTQUFLO0FBQUMsUUFBQSxXQUFNLEdBQUU7QUFDZCxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBRUosT0FESztBQUNMLElBQUUsYUFBYSxDQUFDLEdBQVc7QUFBSSxRQUMzQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDckIsWUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNyQyxZQUNNLE9BQU87QUFDYixTQUFLO0FBQ0wsUUFDSSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNwQyxJQUFFLENBQUM7QUFDSDs0S0FBQztBQUNELHVPQXhCSztBQUFDO0VBSEwsVUFBVSxTQUFDLHJCQUlJLFlBTlAsUUFBUTtlQUdmLGZBSG1CLFlBRkEsUUFBUTtFQUtqQixGQUxvQjtDQUtsQixNQUFNLGVBQ25COzs7OztvR0FOaUM7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQWJzdHJhY3ROYXZpZ2F0b3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IHJvdXRlcj86IFJvdXRlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxvY2F0aW9uOiBMb2NhdGlvbiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucm91dGVyID0gaW5qZWN0b3IuZ2V0KFJvdXRlcik7XG4gICAgfSBjYXRjaCB7fVxuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyB0byB0aGUgc3BlY2lmaWVkIHVybC4gVGhlIHJvdXRlciB3aWxsIGJlIHVzZWQgaWYgb25lIGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGl0IGZhbGxzIGJhY2tcbiAgICogdG8gYHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZWAuXG4gICAqIEBwYXJhbSB1cmwgVGhlIHVybCB0byBuYXZpZ2F0ZSB0b1xuICAgKi9cbiAgbmF2aWdhdGVCeVVybCh1cmw6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJvdXRlcikge1xuICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybCh1cmwpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlU3RhdGUodXJsKTtcbiAgfVxufVxuIl19